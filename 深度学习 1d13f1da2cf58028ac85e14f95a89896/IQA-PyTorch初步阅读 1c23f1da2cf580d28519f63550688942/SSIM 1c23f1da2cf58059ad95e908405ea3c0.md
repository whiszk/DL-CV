# SSIM

<aside>
ğŸ‘“

@whiszk 

03/21/2025 

</aside>

---

## ä¸€ã€æŒ‡æ ‡åŸç†

**SSIM**ï¼ˆç»“æ„ç›¸ä¼¼æ€§æŒ‡æ•°ï¼ŒStructural Similarity Indexï¼‰æ˜¯ä¸€ä¸ªç”¨äºè¡¡é‡ä¸¤å¹…å›¾åƒä¹‹é—´ç›¸ä¼¼åº¦çš„æŒ‡æ ‡ï¼Œä¸»è¦ç”¨äºå›¾åƒè´¨é‡è¯„ä¼°ã€‚SSIMçš„æå‡ºæ˜¯ä¸ºäº†å…‹æœä¼ ç»Ÿçš„å›¾åƒè´¨é‡è¯„ä¼°æ–¹æ³•ï¼ˆå¦‚å³°å€¼ä¿¡å™ªæ¯”PSNRï¼‰çš„ä¸€äº›å±€é™æ€§ï¼Œæ¯”å¦‚è¿™äº›ä¼ ç»Ÿæ–¹æ³•æœªèƒ½å……åˆ†è€ƒè™‘**äººçœ¼è§†è§‰ç³»ç»Ÿçš„æ„ŸçŸ¥ç‰¹æ€§**ã€‚

### 1.åŸºæœ¬SSIM

SSIMé€šè¿‡æ¨¡æ‹Ÿäººçœ¼å¯¹å›¾åƒçš„æ„ŸçŸ¥ç‰¹æ€§æ¥è¯„ä¼°å›¾åƒçš„è´¨é‡ï¼Œä¸»è¦è€ƒè™‘ä»¥ä¸‹ä¸‰ä¸ªæ–¹é¢çš„æ€§è´¨ï¼š

1. **äº®åº¦**ï¼ˆLuminanceï¼‰ï¼šè¦è¡¡é‡ä¸¤å¹…å›¾åƒçš„å¹³å‡äº®åº¦çš„å·®å¼‚ï¼Œæ¯”è¾ƒåƒç´ å€¼å¤§å°å³å¯ã€‚
    - å›¾åƒä¸­å„åƒç´ ç‚¹çš„**å¹³å‡åƒç´ å€¼**ï¼š
    
    $$
    \mu _{x}=\frac{1}{N}\sum_{i=1}^{N}xi
    $$
    
    - **å¯¹æ¯”å‡½æ•°**ï¼Œå€¼åŸŸä¸º (0,1] ã€‚å½“ä¸”ä»…å½“ $\mu_x == \mu_y$ å–åˆ°æœ€å¤§å€¼1
        
        $$
        l\left(x,y\right)=\frac{2\mu_{x}\mu_{y}+C_{1}}{\mu_x^{2}+\mu_y^{2}+C_1}
        $$
        
    - å¸¸æ•°æ˜¯ä¸ºäº†é˜²æ­¢åˆ†æ¯ä¸ºé›¶
2. **å¯¹æ¯”åº¦**ï¼ˆContrastï¼‰ï¼šæŒ‡çš„æ˜¯å›¾åƒä¸­äº®åº¦çš„æ³¢åŠ¨æˆ–æ ‡å‡†å·®ã€‚
    - **ç°åº¦æ ‡å‡†å·®**ï¼š
    
    $$
    \sigma_x=\left(\frac{1}{N-1}\sum_{i=1}^{N}\left(x_i-\mu_x\right)^2\right)^{\frac{1}{2}}
    $$
    
    - å¯¹æ¯”å‡½æ•°ï¼Œå€¼åŸŸåŒä¸Š
        
        $$
        c(x,y)=\frac{2\sigma_x\sigma_y+C_2}{\sigma_x^2+\sigma_y^2+C_2}
        $$
        
3. **ç»“æ„**ï¼ˆStructureï¼‰ï¼šå›¾åƒå†…å®¹çš„ç»“æ„ä¿¡æ¯ï¼Œé€šè¿‡æ¯”è¾ƒå›¾åƒå±€éƒ¨ç»“æ„çš„ç›¸ä¼¼æ€§æ¥è¯„ä¼°ã€‚
    - ä¸¤å¼ å›¾**åæ–¹å·®**ï¼š
        
        $$
        \sigma_{xy}=\frac{1}{N-1}\sum_{i=1}^{N}(x_i-\mu_x)(y_i-\mu_y)
        $$
        
    - æ¯”è¾ƒå‡½æ•°ï¼š
        
        $$
        s(x,y)=\frac{\sigma_{xy}+C_3}{\sigma_x\sigma_y+C_3}
        $$
        

ç»¼åˆä¸Šè¿°æ€§è´¨ï¼Œ**SSIMçš„æœ€ç»ˆè¡¨è¾¾å¼**ä¸ºï¼š

$$
S(x,y)=l(x,y)^{\alpha}\cdot c(x,y)^{\beta}\cdot s(x,y)^{\gamma}
$$

- å½“$\alpha,\beta,\gamma$éƒ½å–**1**æ—¶ï¼Œæœ‰ï¼š

$$
SSIM(x,y)=\frac{(2\mu_x\mu_y+C_1)(2\sigma_{xy}+C_2)}{(\mu_x^2+\mu_y^2+C_1)(\sigma_x^2+\sigma_y^2+C_2)}
$$

- å…¶ä¸­ï¼š

$$
C_1=(K_1L)^2,C_2=(K_2L)^2,C_3=C_2/2
$$

- å¹¶ä¸”$K_1=0.01,K_2=0.03$ï¼Œè¿™æ˜¯ä¹ æƒ¯å–å€¼ï¼Œ**Lä¸ºæœ€å¤§åƒç´ å€¼**ï¼Œå¦‚8ä½å›¾åƒçš„Lä¸º255

---

### 2.å®é™…åº”ç”¨çš„SSIMå…¬å¼

ä½†åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¹¶ä¸ä¼šå¯¹æ•´å¼ å›¾ç‰‡æ±‚å‡å€¼ã€æ–¹å·®ï¼Œæˆ‘ä»¬ä¹ æƒ¯ä»¤**å¤§å°ä¸º11Ã—11ï¼Œæ ‡å‡†å·®ä¸º1.5ï¼Œå’Œä¸º1çš„é«˜æ–¯æ ¸**ä½œä¸ºæ»‘åŠ¨çª—å£ï¼Œå¯¹ä¸¤å¼ å›¾ç‰‡åŒæ­¥å–çª—å£ï¼Œè®¡ç®—æ¯ä¸ªçª—å£ä¸­å¿ƒåƒç´ ç‚¹çš„SSIMï¼Œæœ€åæ±‚å‡å€¼ã€‚

- çª—å£å¯ä»¥è¿™æ ·ç†è§£ï¼šä¸åŒäºç›´æ¥å–è¯¥åƒç´ ç‚¹çš„åƒç´ å€¼ï¼Œåˆ©ç”¨é«˜æ–¯æ ¸æ¥è®¡ç®—æ—¶ï¼Œ**æ¯ä¸ªåƒç´ ç‚¹çš„å€¼æ˜¯æ ¹æ®å…¶å‘¨å›´åŒºåŸŸå„ç‚¹åƒç´ å€¼çš„åŠ æƒå‡å€¼æ¥è®¡ç®—çš„ï¼Œç›¸å½“äºå¼•å…¥äº†å¹³æ»‘å…ˆéªŒï¼Œ**å³å°†å®ƒå‘¨å›´åŒºåŸŸçš„ä¿¡æ¯çº³å…¥è€ƒè™‘ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒèƒ½**ä½“ç°å±€éƒ¨ä¿¡æ¯**
- æ‰€ä»¥å‡å€¼ï¼Œæ ‡å‡†å·®ï¼Œåæ–¹å·®çš„è®¡ç®—å…¬å¼å‘ç”Ÿäº†ä¸€äº›å˜åŒ–ï¼ˆè¿™é‡Œä¸ç¡®å®šiçš„æ•°é‡ï¼Œå¦‚æœè€ƒè™‘è¾¹ç•Œæ•ˆåº”ï¼Œiçš„æ•°é‡ä¸é«˜æ–¯æ ¸å¤§å°æœ‰å…³ï¼‰

$$
\mu_x=\sum_iw_ix_i
$$

$$
\sigma_x=(\sum_iw_i(x_i-\mu_x)^2)^{\frac{1}{2}}
$$

$$
\sigma_{xy}=\sum_iw_i(x_i-\mu_x)(y_i-\mu_y)
$$

ï¼ˆ$w_i$çš„è®¡ç®—æ”¾åœ¨åæ–‡ï¼‰

- ä½†SSIMçš„æœ€ç»ˆè¡¨è¾¾å¼è¿˜æ˜¯ä¸å˜:

è¿™æ ·åšçš„ä¼˜ç‚¹åœ¨äºï¼š

- **ä¸­å¿ƒåŠ æƒç‰¹æ€§**ï¼šè¿™æ ·é‡‡æ ·ä½¿å¾—çª—å£ä¸­å¿ƒåƒç´ çš„æƒé‡æœ€é«˜ï¼Œå‘è¾¹ç¼˜é€æ¸è¡°å‡ã€‚è¿™æ¨¡æ‹Ÿäº†**äººçœ¼å¯¹å›¾åƒä¸­å¿ƒåŒºåŸŸæ›´æ•æ„Ÿ**çš„ç‰¹ç‚¹ï¼Œä½¿SSIMè¯„åˆ†æ›´è´´è¿‘**ä¸»è§‚æ„ŸçŸ¥**ã€‚
- **æŠ‘åˆ¶è¾¹ç•Œçªå˜**ï¼šåœ¨å‡åŒ€çª—å£ä¸­ï¼Œçª—å£è¾¹ç¼˜åƒç´ çš„çªç„¶è¿›å…¥æˆ–é€€å‡ºå¯èƒ½å¯¼è‡´å±€éƒ¨ç»Ÿè®¡é‡ï¼ˆå¦‚å‡å€¼ã€æ–¹å·®ï¼‰çš„çªå˜ã€‚é«˜æ–¯æ ¸çš„å¹³æ»‘è¡°å‡é™ä½äº†è¿™ç§æ•ˆåº”ï¼Œä½¿SSIMè´¨é‡å›¾æ›´å¹³æ»‘ã€‚

---

## äºŒã€ä»£ç æ‹†è§£

### 1.ssimå‡½æ•°

```python
è·¯å¾„ï¼š/home/whiszk/IQA-PyTorch/pyiqa/archs/ssim_arch.py

import numpy as np
import torch
import torch.nn.functional as F

from pyiqa.utils.color_util import to_y_channel
from pyiqa.matlab_utils import fspecial, SCFpyr_PyTorch, math_util, filter2
from pyiqa.utils.registry import ARCH_REGISTRY
from .func_util import preprocess_rgb

def ssim(
    X,
    Y,
    win=None,
    get_ssim_map=False,
    get_cs=False,
    get_weight=False,
    downsample=False,
    data_range=1.0,
):
		'''ç”Ÿæˆé»˜è®¤é«˜æ–¯æ ¸ï¼Œto(X)è¡¨ç¤ºå’ŒXæ”¾åœ¨ä¸€ä¸ªè®¾å¤‡ä¸Šè®¡ç®—'''
    if win is None:
        win = fspecial(11, 1.5, X.shape[1]).to(X)

		'''ç”Ÿæˆå¸¸æ•°é¡¹ï¼Œå–å€¼ä¸å‰æ–‡å…¬å¼ç›¸åŒ'''
    C1 = (0.01 * data_range) ** 2
    C2 = (0.03 * data_range) ** 2

    '''
    è®¡ç®—é™é‡‡æ ·å› å­ï¼Œå–é•¿å®½ä¸­çš„å°å€¼ï¼Œè®¡ç®—æ¯”ä¾‹ï¼Œä½¿æœ€å°è¾¹é•¿æ¥è¿‘ 256 åƒç´ 
    å››èˆäº”å…¥å–æ•´æ¯”ä¾‹fï¼Œfæœ€å°ä¸º1ï¼Œå¦åˆ™ä¼šå˜ä¸ºæ”¾å¤§
    '''
    f = max(1, round(min(X.size()[-2:]) / 256))
    if (f > 1) and downsample:
        X = F.avg_pool2d(X, kernel_size=f)
        Y = F.avg_pool2d(Y, kernel_size=f)

		'''
		ç”¨é«˜æ–¯æ ¸å¯¹å›¾åƒè¿›è¡Œå·ç§¯ï¼Œå¹¶è®¡ç®—å‡å€¼çš„å¹³æ–¹ï¼Œä¹˜ç§¯ç­‰ä¾¿äºåæ–‡è®¡ç®—
		æ³¨æ„æ­¤å¤„çš„muä¸ºå¼ é‡ï¼Œå­˜å‚¨æ¯å¼ å›¾ç‰‡ï¼Œé€šé“çš„æ¯ä¸ªåƒç´ ç‚¹çš„é«˜æ–¯åŠ æƒå‡å€¼çŸ©é˜µ
		'valid'æ¨¡å¼ä¸‹ï¼Œä¸å¡«å……ï¼Œè¾¹ç¼˜ä¸å·ç§¯ï¼Œè¾“å‡ºå›¾åƒçš„å°ºå¯¸ä¼šå°äºè¾“å…¥å›¾åƒçš„å°ºå¯¸
		'''
    mu1 = filter2(X, win, 'valid')
    mu2 = filter2(Y, win, 'valid')
    mu1_sq = mu1.pow(2)
    mu2_sq = mu2.pow(2)
    mu1_mu2 = mu1 * mu2
    
    '''
    æ–¹å·®ï¼šå¹³æ–¹çš„æœŸæœ›å‡æœŸæœ›çš„å¹³æ–¹
    åæ–¹å·®ï¼šä¸¤è€…ç§¯çš„å·ç§¯æœŸæœ›å‡å»ä¸¤è€…å·ç§¯æœŸæœ›çš„ç§¯
    '''
    sigma1_sq = filter2(X * X, win, 'valid') - mu1_sq
    sigma2_sq = filter2(Y * Y, win, 'valid') - mu2_sq
    sigma12 = filter2(X * Y, win, 'valid') - mu1_mu2

		'''cs_mapè¿”å›çš„æ˜¯å¯¹æ¯”åº¦å’Œç»“æ„ç›¸ä¼¼æ€§çƒ­å›¾ï¼Œæ²¡æœ‰è€ƒè™‘äº®åº¦,reluæ˜¯ä¸ºäº†é˜²æ­¢å–è´Ÿ'''
    cs_map = (2 * sigma12 + C2) / (sigma1_sq + sigma2_sq + C2)
    cs_map = F.relu(cs_map)
    
    '''
    åº”ç”¨æœ€ç»ˆçš„ssimè®¡ç®—å…¬å¼ï¼Œå‰æ–‡è®¡ç®—çš„muç­‰å‚æ•°ä¸€ç›´ä»¥çŸ©é˜µè€Œä¸æ˜¯æ•°å€¼å½¢å¼å­˜å‚¨
    ssim_mapå’Œssim_valçš„åŒºåˆ«ä»…ä»…åœ¨äºæœ‰æ²¡æœ‰å–å…¨å›¾å¹³å‡
    ssim_valå¾—åˆ°æ¯å¼ å›¾åƒçš„ssimï¼ˆä¸€ç»´ï¼‰
    '''
    ssim_map = ((2 * mu1_mu2 + C1) / (mu1_sq + mu2_sq + C1)) * cs_map
    ssim_val = ssim_map.mean([1, 2, 3])

		 '''weightæ˜¯åˆ»ç”»å¯¹æ¯”åº¦è¿™ä¸€ä¸ªå±æ€§çš„ï¼Œä¸xyç»´æ•°ç›¸åŒçš„å¼ é‡'''
    if get_weight:
        weights = torch.log((1 + sigma1_sq / C2) * (1 + sigma2_sq / C2))
        return ssim_map, weights

    if get_ssim_map:
        return ssim_map
		
    if get_cs:
        return ssim_val, cs_map.mean([1, 2, 3])

    return ssim_val
```

**å‚æ•°ä¸å‡½æ•°ï¼š**

- `X, Y`ï¼šè¾“å…¥çš„ä¸¤å¼ å›¾åƒï¼ˆPyTorchå¼ é‡ï¼‰ã€‚
- `win`ï¼šç”¨äºSSIMè®¡ç®—çš„é«˜æ–¯åŠ æƒæ ¸ï¼ˆå¦‚æœä¸º `None`ï¼Œåˆ™è‡ªåŠ¨ç”Ÿæˆï¼‰ã€‚
- `get_ssim_map`ï¼šæ˜¯å¦è¿”å› SSIM è®¡ç®—çš„**å±€éƒ¨ SSIM æ˜ å°„**ï¼ˆå³è®¡ç®—ssim_valå‡å€¼å‰çš„æ•°å€¼çŸ©é˜µï¼‰ï¼Œä¸ºtrueçš„è¯ï¼Œå°±è¿”å›æ¯ä¸ªåƒç´ çš„SSIMå€¼ï¼Œå³ä¸€ä¸ªæ•°å€¼çŸ©é˜µï¼ˆå¤§å°ä¸ç¡®å®šï¼Œå–å†³äº`filter2`è®¡ç®—æ—¶æ˜¯å¦è€ƒè™‘è¾¹ç•Œæ•ˆåº”ï¼‰
- `get_cs`ï¼šæ˜¯å¦è¿”å›å¯¹æ¯”åº¦å’Œç»“æ„ç›¸ä¼¼æ€§ã€‚
- `get_weight`ï¼šæ˜¯å¦è¿”å›å¯¹æ¯”åº¦ç›¸ä¼¼æ€§ã€‚
- `downsample`ï¼šæ˜¯å¦è¿›è¡Œé™é‡‡æ ·ï¼ˆä¸å®˜æ–¹ Matlab ä»£ç ä¿æŒä¸€è‡´ï¼‰ã€‚
- `data_range`ï¼šå•ä¸ªåƒç´ ç‚¹çš„æœ€å¤§åƒç´ å€¼ï¼ˆé»˜è®¤ä¸º `1.0`ï¼Œé€‚ç”¨äºå½’ä¸€åŒ–å›¾åƒï¼‰ã€‚

- `F.avg_pool2d` ç”¨äºå¯¹å¼ é‡è¿›è¡Œæ± åŒ–å¤„ç†
- `filter2(X, win, 'valid')` è¡¨ç¤ºç”¨é«˜æ–¯æ ¸å¯¹ X è¿›è¡ŒäºŒç»´å·ç§¯ï¼Œè®¡ç®—å¾—åˆ°å‡å€¼ï¼Œåœ¨ `'valid'` æ¨¡å¼ä¸‹ï¼Œä¸å¡«å……ï¼Œè¾¹ç¼˜ä¸å·ç§¯ï¼Œå·ç§¯çš„ç»“æœåªåŒ…æ‹¬é‚£äº›å®Œå…¨åœ¨åŸå›¾åƒå†…çš„åŒºåŸŸï¼Œå³å·ç§¯æ ¸çª—å£å¿…é¡»å®Œå…¨åœ¨å›¾åƒçš„è¾¹ç•Œå†…ã€‚å› æ­¤ï¼Œè¾“å‡ºå›¾åƒçš„å°ºå¯¸ä¼šå°äºè¾“å…¥å›¾åƒçš„å°ºå¯¸

---

### 2.ms_ssimå‡½æ•°

```python
'''
msssimæ˜¯å¤šå°ºåº¦(åˆ†è¾¨ç‡)åŠ æƒçš„ssimï¼Œ
ä¸åŒå°ºåº¦ä¸‹ï¼Œå›¾åƒçš„ç»†èŠ‚å’Œç»“æ„ä¼šæœ‰æ‰€ä¸åŒã€‚
MS-SSIM å€Ÿé‰´äº†å¤šå±‚ç‰¹å¾æå–çš„æ€æƒ³ï¼Œé‡‡ç”¨å¤šå°ºåº¦æ± åŒ–æ¥æ¨¡æ‹Ÿä¸åŒå±‚æ¬¡çš„è§†è§‰æ„ŸçŸ¥
å¹¶å¯¹ä¸åŒå°ºåº¦çš„ SSIM åˆ†æ•°è¿›è¡ŒåŠ æƒèåˆ

éœ€è¦æ³¨æ„çš„æ˜¯ï¼šå¤šå°ºåº¦ç»“æ„ç›¸ä¼¼æ€§æŒ‡æ•°ï¼ˆMSSSIMï¼‰è®¡ç®—ä¸­ï¼Œå¯¹æ¯”åº¦å’Œç»“æ„æ˜¯ä¸»è¦çš„å…³æ³¨ç‚¹ï¼Œ
äº®åº¦é€šå¸¸ä¸ä¼šåœ¨å¤šä¸ªå°ºåº¦ä¹‹é—´å˜åŒ–æ—¶è¢«æ˜¾è‘—è€ƒè™‘
'''

def ms_ssim(
    X,
    Y,
    win=None,
    data_range=1.0,
    downsample=False,
    test_y_channel=True,
    is_prod=True,
    color_space='yiq',
):
    if not X.shape == Y.shape:
        raise ValueError('Input images must have the same dimensions.')
		
		'''ä¸åŒå°ºåº¦å¯¹åº”çš„æƒé‡'''
    weights = torch.FloatTensor([0.0448, 0.2856, 0.3001, 0.2363, 0.1333]).to(X)

    levels = weights.shape[0]
    
    '''mcsä»£è¡¨åœ¨æ¯ä¸ªå°ºåº¦ä¸‹ï¼Œå›¾åƒçš„å¯¹æ¯”åº¦ä¸ç»“æ„ç›¸ä¼¼åº¦'''
    mcs = []

    for _ in range(levels):
        ssim_val, cs = ssim(
            X,
            Y,
            win=win,
            get_cs=True,
            downsample=downsample,
            data_range=data_range,
        )
        mcs.append(cs)
        
        '''æ”¹å˜å°ºåº¦ï¼Œç”¨äºè¿›è¡Œä¸‹ä¸€å±‚è®¡ç®—ï¼Œè¿™é‡Œä½¿ç”¨æ˜¯å¹³å‡æ± åŒ–'''
        padding = (X.shape[2] % 2, X.shape[3] % 2)
        X = F.avg_pool2d(X, kernel_size=2, padding=padding)
        Y = F.avg_pool2d(Y, kernel_size=2, padding=padding)

    mcs = torch.stack(mcs, dim=0)

		'''is_prodä¸ºtrueæ—¶ï¼Œå°ºåº¦åŠ æƒä¸ºä¹˜ç§¯æ¨¡å¼ï¼Œå¦åˆ™ä¸ºåŠ å’Œæ¨¡å¼'''
    if is_prod:
        msssim_val = torch.prod((mcs[:-1] ** weights[:-1].unsqueeze(1)), dim=0) * (
            ssim_val ** weights[-1]
        )
    else:
        weights = weights / torch.sum(weights)
        msssim_val = torch.sum((mcs[:-1] * weights[:-1].unsqueeze(1)), dim=0) + (
            ssim_val * weights[-1]
        )

    return msssim_val
    
```

**å‚æ•°ä¸å‡½æ•°ï¼š**

- `is_prod` å†³å®šæ˜¯ä»¥ä¹˜ç§¯è¿˜æ˜¯åŠ å’Œçš„æ–¹å¼æ¥åˆå¹¶å¤šå°ºåº¦çš„ç»“æ„ç›¸ä¼¼åº¦
- `mcs = torch.stack(mcs, dim=0)` ç”¨äºæ‹¼æ¥å„ä¸ªå°ºåº¦çš„cså¼ é‡ï¼Œä¾¿äºåç»­è®¡ç®—
- æœ€å°å°ºåº¦çš„csä¿¡æ¯æœ€ä¸ºé‡è¦ï¼Œæ¯ä¸ªå°ºåº¦çš„ä¿¡æ¯éƒ½éœ€è¦ä¸å…¶ç»“åˆè®¡ç®—

---

### 3.ssimç±»

```python
'''è¿™æ˜¯åŸºæœ¬çš„ssimç±»,ms_ssimå’Œcw_ssimç±»ä¹Ÿæ˜¯åŒç†'''

@ARCH_REGISTRY.register()
class SSIM(torch.nn.Module):
    def __init__(
        self,
        channels=3,
        downsample=False,
        test_y_channel=True,
        color_space='yiq',
        crop_border=0.0,
    ):
        super(SSIM, self).__init__()
        self.downsample = downsample
        self.test_y_channel = test_y_channel
        self.color_space = color_space
        self.crop_border = crop_border
        self.data_range = 255

    def forward(self, X, Y):
        assert X.shape == Y.shape, (
            f'Input {X.shape} and reference images should have the same shape'
        )

        if self.crop_border != 0:
            crop_border = self.crop_border
            X = X[..., crop_border:-crop_border, crop_border:-crop_border]
            Y = Y[..., crop_border:-crop_border, crop_border:-crop_border]
				
				'''RGBé¢„å¤„ç†ï¼ŒåŒ…æ‹¬æ˜¯å¦è½¬ä¸ºyé€šé“ï¼Œæ˜¯å¦è½¬æ¢ä¸ºæŒ‡å®šé¢œè‰²ç©ºé—´ç­‰'''
        X = preprocess_rgb(
            X, self.test_y_channel, self.data_range, self.color_space
        ).to(torch.float64)
        Y = preprocess_rgb(
            Y, self.test_y_channel, self.data_range, self.color_space
        ).to(torch.float64)

        score = ssim(X, Y, data_range=self.data_range, downsample=self.downsample)
        return score
```

**å‚æ•°ä¸å‡½æ•°ï¼š**

- ç»§æ‰¿moduleç±»åï¼ŒåŒæ ·é‡è½½äº†initå’Œforwardå‡½æ•°
- `crop_border`:å¯¹è¾“å…¥å›¾åƒè£è¾¹çš„åƒç´ æ•°

---

### 4.preprocess_rgbå‡½æ•°

```python
è·¯å¾„ï¼š/home/whiszk/IQA-PyTorch/pyiqa/archs/func_util.py

'''ç”¨äºé¢„å¤„ç†rgbå¼ é‡'''
def preprocess_rgb(x, test_y_channel, data_range: float = 1, color_space='yiq'):
    if test_y_channel and x.shape[1] == 3:
        x = to_y_channel(x, data_range, color_space)
    else:
        x = x * data_range

    if data_range == 255:
        x = x - x.detach() + x.round()
    return x

```

**å‚æ•°ä¸å‡½æ•°ï¼š**

- `data_range` è¡¨ç¤ºå½’ä¸€åŒ–çš„æ ‡å‡†
- `test_y_channel` è¡¨ç¤ºæ˜¯å¦åªæå–yé€šé“çš„ä¿¡æ¯
- `x = x - x.detach() + x.round()` å…ˆå°†åƒç´ å€¼å››èˆäº”å…¥åˆ°æ•´æ•°ï¼Œ`x - x.detach()` çš„ç›®çš„æ˜¯ç¡®ä¿å››èˆäº”å…¥åçš„å€¼ä¸åŸå§‹å¼ é‡ `x` çš„æ¢¯åº¦è®¡ç®—å®Œå…¨æ²¡æœ‰å…³ç³»ï¼Œä»è€Œä¸ä¼šå½±å“åç»­çš„åå‘ä¼ æ’­ã€‚
å¯ä»¥è¿™æ ·ç†è§£ï¼Œå››èˆäº”å…¥çš„å€¼ç”¨äº**å‰å‘ä¼ æ’­**ï¼ŒåŸåœ°åˆ‡å‰²ç•™ä¸‹ä¸€ä¸ªæ²¡æœ‰ç»è¿‡å››èˆäº”å…¥çš„å°æ•°ç‰ˆæœ¬ï¼Œç”¨äºåå‘ä¼ æ’­æ—¶ç²¾ç¡®çš„**æ¢¯åº¦è®¡ç®—**

---

## ä¸‰ã€çŸ¥è¯†è¡¥å…¨

### 1.é«˜æ–¯æ ¸

é«˜æ–¯æ ¸æ˜¯ä¸€ç§**å·ç§¯æ ¸**ï¼Œä¹Ÿè¢«ç§°ä¸ºâ€œ**ç‰¹å¾è¿‡æ»¤å™¨**â€ï¼Œåœ¨å›¾åƒå¤„ç†ä¸­å¾ˆå¸¸è§ï¼Œä¸»è¦ç”¨äº**å¹³æ»‘å›¾åƒã€é™ä½å™ªå£°ï¼Œ**å…¶æ¥æºäºé«˜æ–¯å‡½æ•°ï¼ˆæ­£æ€åˆ†å¸ƒæ›²çº¿ï¼‰ï¼Œå®ƒçš„å·ç§¯æ“ä½œä¼šè®©å›¾åƒâ€œæ¨¡ç³Šâ€ä¸€äº›ï¼ŒæŠŠç»†èŠ‚å¹³æ»‘æ‰ã€‚å®ƒæ˜¯ä¸€ç§**çº¿æ€§æ»¤æ³¢å™¨**ï¼Œæ²¡æœ‰å­¦ä¹ å‚æ•°ï¼Œæ˜¯**å›ºå®šæƒé‡çš„å·ç§¯æ ¸**ã€‚

æ•°å­¦å…¬å¼ä¸ºï¼š

$$
G(x,y)=\frac{1}{2\pi\sigma^2}\cdot exp(-\frac{x^2+y^2}{2\sigma^2})
$$

å…¶ä¸­ï¼š

- (x,y)æ˜¯å½“å‰åƒç´ ç‚¹ç›¸å¯¹äºä¸­å¿ƒåƒç´ ç‚¹çš„åæ ‡
- $\sigma$æ˜¯æ ‡å‡†å·®ï¼Œæ§åˆ¶æ¨¡ç³Šç¨‹åº¦
- G(x,y)ä¸ºä½ç½®(x,y)çš„åƒç´ ç‚¹å¯¹åº”å€¼æƒé‡
- æ•´ä¸ªæ ¸æœ€åä¼šè¢«å½’ä¸€åŒ–ï¼š$\sum G(x,y) = 1$

åœ¨IQA-PyTorchçš„é¡¹ç›®æºç ä¸­ï¼Œå®ç°äº†ä¸€ä¸ªfspecialå‡½æ•°ï¼Œç”¨äºç”Ÿæˆä¸€ä¸ªæ ¸windowï¼Œå…¶å¯ä»¥ç›´æ¥ç”¨ä½œfilter2ç­‰å‡½æ•°çš„å‚æ•°ï¼Œå¦‚ä¸‹ï¼š

```python
è·¯å¾„ï¼š/home/whiszk/IQA-PyTorch/pyiqa/matlab_utils/functions.py

def fspecial(size=None, sigma=None, channels=1, filter_type='gaussian'):
  
  '''ç›®å‰åªæ”¯æŒç”Ÿæˆé«˜æ–¯æ ¸'''
  if filter_type == 'gaussian':
		
		'''å°†å•ä¸ªæ•´æ•°å˜æˆ (size, size) çš„äºŒå…ƒç»„'''
    shape = to_2tuple(size)
    
    '''m,nä¸ºçª—å£ä¸­å¿ƒåæ ‡ï¼Œ0base'''
    m, n = [(ss - 1.0) / 2.0 for ss in shape]
    
    '''ç”ŸæˆäºŒç»´åæ ‡ç½‘æ ¼'''
    y, x = np.ogrid[-m : m + 1, -n : n + 1]
    
    '''æ²¡æœ‰å¸¸æ•°é¡¹çš„é«˜æ–¯å…¬å¼ï¼Œå¹¶ç½®é›¶è¿‡å°æ•°å€¼'''
    h = np.exp(-(x * x + y * y) / (2.0 * sigma * sigma))
    h[h < np.finfo(h.dtype).eps * h.max()] = 0
    
    '''å½’ä¸€åŒ–ï¼Œå°†hè½¬ä¸ºPyTorch tensorå¹¶æ‰©å±•é€šé“'''
    sumh = h.sum()
    if sumh != 0:
        h /= sumh
    h = torch.from_numpy(h).float().repeat(channels, 1, 1, 1)
    return h
  else:
    raise NotImplementedError(
        f'Only support gaussian filter now, got {filter_type}'
    )
        
```

- `y, x = np.ogrid[-m : m + 1, -n : n + 1]` å½“mï¼Œnéƒ½ä¸º2æ—¶ï¼Œæœ‰ï¼š
    
    x = [[-2, -1,  0,  1,  2]]   # æ°´å¹³æ–¹å‘åç§»
    y = [[-2], [-1], [0], [1], [2]]   # å‚ç›´æ–¹å‘åç§»
    

---

### 2.é²æ£’æ€§

**é²æ£’æ€§**ï¼Œè‹±æ–‡ä¸ºRobustnessï¼ˆæ‰¿å—æ•…éšœå’Œå¹²æ‰°çš„èƒ½åŠ›ï¼‰ï¼Œæ˜¯è®¸å¤šå¤æ‚ç³»ç»Ÿï¼ˆåŒ…æ‹¬å¤æ‚ç½‘ç»œï¼‰çš„å…³é”®å±æ€§ã€‚

ä¸ç¨³å®šæ€§çš„åŒºåˆ«ï¼šç¨³å®šæ€§æ˜¯æŒ‡ç³»ç»Ÿå—åˆ°ç¬æ—¶æ‰°åŠ¨ï¼Œæ‰°åŠ¨æ¶ˆå¤±åç³»ç»Ÿå›åˆ°åŸæ¥çŠ¶æ€çš„èƒ½åŠ›ï¼Œè€Œé²æ£’æ€§æ˜¯æŒ‡ç³»ç»Ÿå—åˆ°æŒç»­æ‰°åŠ¨èƒ½ä¿æŒåŸæ¥çŠ¶æ€çš„èƒ½åŠ›ã€‚

---

### 3.è¾¹ç¼˜æ•ˆåº”

**è¾¹ç¼˜æ•ˆåº”**ï¼Œæ˜¯æŒ‡åœ¨å›¾åƒçš„**è¾¹ç¼˜åŒºåŸŸ**è¿›è¡Œå·ç§¯æ“ä½œæ—¶ï¼Œç”±äº**ç¼ºå°‘è¶³å¤Ÿçš„é‚»åŸŸåƒç´ **ï¼Œå¯¼è‡´å·ç§¯ç»“æœä¸å‡†ç¡®æˆ–ä¸å¯è®¡ç®—çš„ç°è±¡ï¼Œå¸¸è§çš„è¾¹ç¼˜å¤„ç†æ–¹å¼æœ‰ï¼š

- valid ï¼šä¸å¡«å……ï¼Œè¾¹ç¼˜ä¸å·ç§¯ï¼Œå›¾åƒè¾“å‡ºå°ºå¯¸å˜å°ï¼ˆå‰æ–‡ssimä»£ç ä¸­é‡‡ç”¨ï¼‰
- same ï¼š é›¶å¡«å……ï¼Œä¿è¯è¾“å‡ºå’Œè¾“å…¥ä¸€æ ·å¤§
- reflect ï¼š è¾¹ç¼˜é•œåƒå¡«å……ï¼Œå¸¸ç”¨äºå›¾åƒ

---

### 4.å·ç§¯ä¸æ± åŒ–ç®€å•ä»‹ç»

å¯ä»¥æŠŠ**å·ç§¯**ç†è§£ä¸ºï¼Œ**å¸¦ç€æœ‰è‰²çœ¼é•œè§‚å¯Ÿå±€éƒ¨åŒºåŸŸçš„ç‰¹å¾ï¼ˆä½“ç°åå¥½æ€§ï¼Œå±€éƒ¨æ€§ï¼‰ï¼Œ**è¿™ç§æ¨¡ä»¿äººçœ¼â€œå±€éƒ¨è§‚å¯Ÿ + æ¨¡å¼è¯†åˆ«â€çš„æœºåˆ¶ï¼Œèƒ½å¸®åŠ©ç¥ç»ç½‘ç»œä»åŸå§‹å›¾åƒä¸­è‡ªåŠ¨æå–æœ‰ç”¨çš„ç»“æ„ç‰¹å¾ã€‚

ä¾‹å¦‚å½“é«˜æ–¯æ ¸ä½œä¸ºå·ç§¯æ ¸æ—¶ï¼Œå®ƒçš„è§‚å¯Ÿåå¥½å°±æ˜¯æ¨¡ç³Šç»†èŠ‚ï¼Œå¹³æ»‘å›¾åƒï¼›CNNä¸­ï¼Œé€šå¸¸å·ç§¯æ ¸ä¸æ˜¯æ‰‹åŠ¨è®¾å®šä¸€æˆä¸å˜çš„ï¼Œè€Œæ˜¯ç½‘ç»œè®­ç»ƒè¿‡ç¨‹ä¸­æ›´æ–°è¿­ä»£çš„ã€‚

**æ± åŒ–**çš„ä½œç”¨ï¼Œå¯ä»¥ç†è§£ä¸ºç‰¹å¾å‹ç¼©ï¼Œæ¯”å¦‚ï¼šmaxpoolingæ–¹å¼ä¼šç­›é€‰å‡ºå½“å‰æ± åŒ–çª—å£ä¸­çš„æœ€å¤§å€¼ï¼Œä¿ç•™å›¾åƒä¸­æœ€å…³é”®çš„ç‰¹å¾ï¼Œå¹¶å‡å°‘ç‰¹å¾å€¼æ•°é‡ï¼Œæ–¹ä¾¿è®¡ç®—ã€‚
æ± åŒ–çª—å£çš„æ­¥é•¿é€šå¸¸å’Œçª—å£å¤§å°ä¸€è‡´ï¼Œè¿™æ ·é‡‡æ ·æ˜æ˜¾ï¼Œä½†ä¹Ÿæœ‰é‡å çš„æƒ…å†µã€‚

![Snipaste_2025-04-06_15-48-30.jpg](SSIM%201c23f1da2cf58059ad95e908405ea3c0/Snipaste_2025-04-06_15-48-30.jpg)